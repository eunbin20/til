# Redux style guide

#### 중요도A

###### - 상태를 직접적으로 수정하지 마라.

  상태를 직접적으로 수정하는 것은 리덕스에서 버그를 유발하는 가장 보편적인 요인이다. 이 버그가 발생하면 컴포넌트는 제대로 리렌더링되지 못하고 리덕스 개발자도구를 해용해 디버깅을 하는 데 많은 시간이 소요됩니다. reducer나 어플리케이션 코드 안에서나 직접으로 state를 변화시키는 것은 언제나 피해야 한다.

  `redux-immutable-state-invariant`와 같은 도구를 사용하면 개발 중에 state를 직접적으로 수정하는 것을 잡아낼 수 있고 `Immer`은 의도치않게 state가 변경되는 것을 방지해준다.

  Note: 존재하는 값을 복사하여 수정하는 것은 괜찮다. 이것은 갱신하는 로직을 불변하게 만드는 일반적인 부분이다. 또한, `Immer` 라이브러리를 사용하면 실제 값이 변하는 것이 아니기 때문에 "수정"하는 로직을 작성하는 것이 가능하다. `Immer`는 내부적으로 변화를 감지하고 불변적인 갱신 로직을 생성해준다.
  </br>

###### - Reducer함수는 순수해야한다.
  reducer함수는 오직 그 함수의 `state`와 `action`인자에 달려있다. 그리고 이 인자들만을 이요해 작업을 수행하고 값을 반환해야 한다. 이 함수에서는 **비동기적인 실행(AJAX 호출, timeout, promise 등)을 하거나 무작위적인 값(Date.now(), Math.random())을 생성하거나, reducer함수 외부의 값을 변화시키거나, 외부의 코드에 영향을 주는 코드를 작성 해서는 안된다.**
  </br>

###### - Serialize할 수 없는 값을 state나 action에 넣지 마라.
  Promise, Symbols, Map/Set 객체, 함수, 클래스의 인스턴스 등 serialize할 수 없는(나열할 수 없는?)값들을 삽입하는 것은 피해라. 이것은 redux의 디버깅 툴을 이용해 디버깅이 예상대로 작동하고 UI가 예상대로 갱신되는 것을 보장해준다.

  예외: 미들웨어때문에 reducer함수에 도달하기 전에 중단되는 경우에는 state나 action에 serialize할 수 없는 값을 삽입할 수 있다. 이러한 미들웨어로는 `redux-thunk`, `redux-promise`등이 있다.
  </br>

###### - 한 어플리케이션 당 store는 하나다.

  표준적인 redux 어플리케이션은 전체 어플리케이션에 사용되는 한 개의 redux store 인스턴스를 가져야 한다. 이것은 전형적으로 store.js와 같은 분리된 파일에서 정의된다.

  이상적으로는, 어플리케이션의 로직이 store를 직접적으로 import하는 것은 좋지 않다. 이것은 <Provider>를 통해 리액트 컴포넌트를 통과할 것이다. 또는 thunk와 같은 미들웨어를 통해 간접적으로 참조할 것이다. 극히 드문 경우에, 다른 로직 파일들에서 store를 import하는 것이 필요할 수도 있지만, 이것은 최후의 수단이 되어야 한다.
</br>

#### 중요도B

###### - Redux toolkit을 사용하여 리덕스 로직을 작성해라.

  `redux toolkit`은 리덕스를 사용할 때 추천하는 툴셋이다. 이것은 우리가 제안하는 모범적인 실행 사례들을 만드는 함수를 포함하고 있다. 이 사례들에는 수정을 감자하기 위해 stor를 세팅하는 것과 리덕스 개발자도구 extension을 사용할 수 있게 하는 것, Immer를 이용해 불변하는 update 로직을 단순화하는 것들이 포함되어있다.

  꼭 RTK(Redux ToolKit)를 사용할 필요는 없습니다. 필요하다면 다른 방안을 사용하는 것도 가능합니다. 그러나 RTK를 사용하면 당신의 로직이 단순해지고 당신의 어플리케이션이 좋은 기본값으로 설정될 것입니다.
  </br>

###### - Immer를 이용해 불변성이 보장되는 로직을 작성해라.

  불변적으로 update되는 로직을 직접 작성하는 것은 빈번하게 어렵고 에러를 발생시키기 쉽다. `Immer`는 당신이 '변하는' 로직을 작성하면서 불변적인 update로직을 간단히 작성할 수 있게 해준다. 그리고 당신의 개발중인 state를 정지시켜 변화를 캐치할 수도 있다. 우리는 불변하는 로직을 작성하기 위해 Immer를 사용하는 것을 추천한다. 가급적이면 redux toolkit의 한 부분으로서.
  </br>

###### - 기능 별 디렉토리 구조를 이용하여 파일 구조를 구성해라.

  리덕스 자체는 당신의 어플리케이션의 폴더와 파일이 어떻게 구성되어있는지 신경쓰지 않는다. 그러나 주어진 기능들을 한 공간안에 위치시키는 것은 유지보수를 좀 더 쉽게 한다.

  그래서, 우리는 **대부분의 어플리케이션이 "feature폴더"접근(모든 feature(기능)을 위한 파일이 같은 폴더에 위치하는 것)을 이용해 파일을 구조화할 것**을 추천한다. 주어진 feature(기능) 폴더 안에서, 해당 기능을 위한 리덕스 로직은 하나씩 slice된 파일로 쓰여야 하고, 가급적이면 `createSlice`리덕스 툴킷을 사용해라. (이것은 "ducks"패턴으로도 알려져있다.) 오래된 리덕스의 코드베이스가 종종 "action", "reducers"로 나누어진 폴더에 접근하는 "folder-by-type"방식을 사용하는 반면 관련된 로직을 한 공간에 저장하는 것은 코드를 찾거나 업데이트하기 쉽게 만들어준다.



###### - 리듀서에 가능한 많은 로직을 넣어라

  어디든 가능하다면, 새로운 state를 계산하는 로직을 prepare나 (이벤트 핸들러같은)action을 dispatch하는 코드보다는 적절한 리듀서 함수에 가능한 많이 넣도록시도해봐라. 이것은 더 많은 실제 어플리케이션 로직이 쉽게 테스트할 수 있게 되고, 시간차 디버깅을 더 효율적으로 만들어주고, mutation이나 버그를 일으키는 일반적인 실수를 막아준다.
  > - 리듀서에 로직을 작성하는 것을 선호하는 것에는 몇가지의 이유가 있다.
    - 리듀서함수는 순수함수이기 때문에, 테스트를 하기 쉽다. 그래서 리듀서에 더 많은 로직을 넣으면 넣을수록 테스팅이 쉬워진다.
    - 리덕스의 state는 언제나 "불변한 갱신"법칙을 따른다.  

###### - 리듀서는 상태모양(State Shape)을 가져야 한다.  

  리덕스의 루트 상태는 루트 리듀서 함수 1개가 가지고 계산한다. 유지보수를 위해, 루트 리듀서는 키/값 “슬라이스(slices)“에 의해 분할되며, 각각의 “슬라이스 리듀서”는 초기값을 제공하고 해당 상태에 대한 업데이트를 계산한다.

  또한, 슬라이스 리듀서는 계산된 상태의 일부로 반환되는 값들을 제어해야 한다. return action.payload 와 return {...state, ...action.payload} 와 같은 “보이지 않는 spread 및 리턴”의 사용을 최소화 해야 하는데 그 이유는, 컨텐츠를 올바른 포맷으로 수정하기 위해 액션을 디스패치하는 코드에 의존하고, 리듀서는 상태가 어떻게 생겼는지 신경을 쓰지 않기 때문이다. 액션의 컨텐츠가 잘못되었다면 이는 버그로 이어질 수 있다.

  참고 : “spread 리턴” 리듀서는 폼의 데이터를 수정하는 것과 같은 경우에 합리적인 선택이 될 수 있는데, 폼의 각 필드에 대해 별도의 액션 타입을 작성하는 것은 시간낭비가 될 수 있고 별로 이득이 없기 때문이다.


###### - slice는 저장되는 데이터에 기반하여 이름을 지어라

리듀서 로직을 분리하는 표준적인 접근방식은 상태의 "슬라이스(slice)"기반이다. 마찬가지로, `combineReducers` 는 이러한 슬라이스 리듀서들을 하나의 거대한 리듀서 함수로 합치는 표준함수이다.

`combineReducers` 에 넘겨지는 객체의 키 이름은 결과적으로 나올 상태 객체의 키 이름을 정의한다. 내부에 저장되는 데이터의 이름을 따서 키 이름을 지정하도록 하고, "reducer"와 같은 이름을 피하자. 객체가 `{userReducer: {}, postsReducer: {}}`보다 `{users: {}, posts: {}}` 와 같이 생겨야 한다는 말이다.

`combineReducers` 는 리듀서 함수가 모두 들어있는 객체를 받고 키 이름과 동일한 상태 객체들을 생성한다. 함수 객체의 키 이름이 상태 객체의 키 이름을 정의한다는 것을 의미한다. 만약 리듀서를 "00reducer"와 같은 변수이름으로 정의할 경우 상태의 이름이 "00reducer"로 정의될 것이다.

명시적으로 `key: value` 문법을 사용해도 좋다.

```jsx
const rootReducer = combineReducers({
  userReducer, // (X)
	users, // (O)
  users: userReducer, // (O)
  // 상태 객체의 이름: 상태 객체를 생성하는 리듀서함수
});
```

###### - 상태 구조는 컴포넌트가 아닌, 데이터 종류에 따라 구성해라

root state의 분할은 UI에서 보여지는 구체적인 컴포넌트가 아니라 주된 데이터 타입들 또는 어플리케이션의 기능적인 영역에 기반하여 정의되어야 한다. 왜냐하면 Redux의 스토어 내부의 데이터와 UI의 컴포넌트 사이에 엄격한 1:1 연결관계가 있는 것이 아니고, 많은 컴포넌트가 같은 데이터에 접근하는 것을 필요로 하기 때문이다. state의 구조를 앱의 어떤 부분이든 해당 컴포넌트에서 필요로 하는 state의 부분에 접근할 수 있는 일종의 global database라고 생각해라.

예를 들어, 블로깅 앱은 누가 로그인했는지, 저자와 posts에 대한 정보, 그리고 아마도 어떤 screen이 활성화되었는지에 대한 정보를 필요로 할 것이다. 좋은 state의 구조는 {auth, posts, users, ui}와 같은 구조일 것이고 나쁜 구조는 {loginScreen, usersList, postsList}일 것이다.

###### - 중첩되고 복잡한 상태를 정규화시켜라.

많은 리덕스의 리듀서들이 "조건없이" 작성되고는 한다. 현재 상태가 어떤지에 대한 아무런 로직 없이 디스패치된 액션만 보고 새로운 상태 값을 계산한다. 이런 습관은 버그를 일으킬 수 있는데, 일부 액션들이 앱의 나머지 로직에 의존하므로 특정 시점에 개념적으로 "유효"하지 않기 때문이다. 예를 들어, "요청 성공" 액션은 상태가 이미 "로딩중"이라고 말하는 경우에만 새로 계산되어야 하며, "항목 업데이트"액션은 항목이 "수정되는 중"일 때만 디스패치 되어야 한다.

이를 고치기 위해서, 액션 자체를 조건없이 다루지말고 현재 상태 그리고 디스패치된 액션 모두의 조함이 새로운 상태 값이 실제로 계산되어야 하는지 여부를 결정하는 "상태 기계"처럼 다뤄야 한다.

유한 상태기계(Finite State Machine)는 특정 시점에 "유한한 상태들 중 하나의 상태를 가져야 하는 모델을 구성하는 유용한 방법이다. 예를 들어, ``fetchUserReducer` 를 가지고 있다면, 유한한 상태들은 다음과 같다.

- "idle" : 시작하지 않은 상태
- "loading": 사용자 정보를 가져오고 있는 상태
- "success": 사용자 정보를 성공적으로 가져옴
- "failure": 사용자 정보를 가져오는데 실패함

위와 같은 상태들에 따라 리듀서를 작성하기 위해 state에서 현재의 상태를 속성으로 가지고있도록 명시해야 한다.

```jsx
const initialUserState {
  state: "idle",
  user: null,
  error: null,
}
```

보통 리듀서 로직은 액션을 먼저 고려해서 작성된다. 그러나 상태기계로 로직을 모델링할 때는, 상태를 먼저 고려하는 것이 중요하다. 각 상태에 대해서 "유한 상태 리듀서"를 만드는 것은 각 상태에 따른 행위를 캡슐화하도록 도와준다.

```jsx
import {
  FETCH_USER,
  //...
} from "./actions";

const IDLE_STAUS = "idle";
const LOADING_STATUS = "loading";
const SUCCESS_STATUS = "success";
const FAILURE_STATUS = "failure";

const fetchIdleUserReducer = (state, action) => {
  switch (action.type) {
    case FETCH_USER:
      return {
        ... status,
        status: LOADING_STATUS
      }
    }
    default:
      return status;
  }
}

const fetchUserReducer = (status, action) => {
  switch (state.status) {
    case IDLE_STATUS:
      return fetchIdleUserReducer(state, action);
    case LOADING_STATUS:
      return fetchLoadingUserReducer(state, action);
    case SUCCESS_STATUS:
      return fetchSuccessUserReducer(state, action);
    case FAILURE_STATUS:
      return fetchFailureUserReducer(state, action);
    default:
			// 여기는 도달하면 안된다.
			return state;
  }
}
```

이제, 액션보다도 상태를 더 우선적으로 분류하여 행위를 정의했기 때문에 불가능한 전환을 막을 수 있다. 예를 들어 FETCH_USER액션은 status가 LOADING_STATUS일 때 실행되지 않을 것이고 예외가 발생하는 경우(edge case)를 따로 정의하지 않고 이를 강제할 수 있다.

###### - 중첩되고 복잡한 상태를 정규화시켜라.(State Nomalizing)

많은 어플리케이션들은 스토어 안에 복접한 데이터를 저장할 때가 있다. 그 데이터는 API로부터 중접된 형채로 받아지거나 데이터 안의 요소들 사이의 관계를 가지고 있다.

그런 데이터를 스토어에 "정규화된 형태"로 저장하자. ID를 통해서 항목을 찾거나 스토어의 단일 항목의 업데이트를 더 쉽게 해주고, 궁극적으로 더 나은 퍼포먼스 패턴으로 이어진다.

###### - 액션은 이벤트처럼 다루어라.

리덕스는 `action.type` 필드의 내용이 뭔지에는 관심이 없다. (-그냥 정의되어야 하는 것이다.) 액션은 현재형(`user.update`), 과거형(`user.updated`), 이벤트형(`user.progress`), 또는 세터(`user.setUserName`)로 다뤄진 경우로 작성할 수 있다. 어플리케이션에서 주어진 액션이 무엇을 의미하는지를 결정하고 어떻게 모델링 할 것인지는 당신에게 달렸다.

그러나, 액션을 set방식보다는 일어나는 이벤트를 묘사하는 방식으로 다룰 것을 추천한다. 액션을 이벤트처럼 다루면 일반적으로 더 의미있는 액션 이름, 디스패치되는 전체 액션 수 감소, 그리고 더 의미있는 액션 로그 기록을 할 수 있게 된다. set방식으로 작성하면 개별 액션 타입들과 디스패치를 너무 많이 작성하게 되고 액션을 이벤트적으로 모델링하는 것보다 덜 의미있는 액션로그를 기록하게 될 것이다.

예시) 식당앱을 개발하는데, 사용자가 피자와 음료 1병을 주문했다고 하자.

액션을 이벤트적으로 모델링하면 다음과 같이 디스패치할 수 있다.

```jsx
// 액션을 이벤트로 모델링
{ type: "food/orderAdded", payload: {pizza: 1, coke: 1} }

// 액션을 set방식으로 모델링
{ type: "orders/setPizzasOrdered", payload: {
  amount: getState().orders.pizza + 1,
  }
}
{ type: "orders/setCokesOrdered", payload: {
  amount: getState().orders.coke + 1,
  }
}
```

1. 액션을 이벤트로 모델링하는 경우: "사용자에게서 주문이 들어왔어. 주문내용은 이거야.(피자1 + 음료1)"
2. 액션을 set방식으로 모델링하는 경우: "'피자주문'과 '음료주문'이라는 필드를 알고있어. 그리고 이 필드들의 값을 다음과 같이 설정해줘.(피자: 주문된 피자 수 + 1, 음료: 주문된 음료 수 + 1)

액션을 이벤트 방식으로 정의하면 단일 액션만 디스패치되고 훨씬 유연하다. set 방식은 액션을 요청하는 부분에서 실제 상태구조에 대해 더 많이 알아야 하고 트랜잭션을 완료하기 위해 여러 개의 액션을 디스패치 해야한다.

###### - 의미있는 액션 이름을 사용해라

`action.type` 필드는 2가지 목적을 가지고 쓰인다.

1. 리듀서의 로직은 액션이 새로운 상태를 계산하는 데 쓰여야 하는가를 보기 위해서 액션 타입을 체크한다.
2. 액션 타입들은 개발자들이 읽을 수 있도록 리덕스 개발자 도구 로그에 보여진다.

'**액션은 Setter가 아닌 이벤트로 모델링하자'**에 따라서, type 필드의 실제 내용은 리덕스 자체와 상관이 없다. 그러나 type값은 개발을 하는 데 있어서는 상관이 있다. **각각의 액션들의 type 필드는 액션의 역할에 대해 의미있고 유용한 정보를 전달하고, 설명하는 방식으로 작성되어야 한다.** 이상적으로, 디스패치되는 액션 타입들을 읽을 수 있어야 하며, 각 액션의 내용을 보지 않고도 어플리케이션에서 어떤 일들이 일어나는지에 대해 명확히 이해할 수 있어야 한다. `SET_DATA` 나 `UPDATE_STORE` 와 같은 포괄적인 액션이름은 피하는 것이 좋은데, 이는 어떤 일이 일어나는지에 대해 의미있는 정보를 제공하지 않기 때문이다.

###### - 하나의 액션에 여러 개의 리듀서가 반응할 수 있게 해라

리덕스의 리듀서 로직은 많은 작은 리듀서들로 나누어진다. 그리고 각각의 리듀서 로직은 각자가 소유하고 있는 state 트리의 한 부분을 업데이트하고 또 모든 로직은 root 리듀서 함수를 형성하기 위해 다시 합쳐진다. 액션이 디스패치되면, 모든 혹은 몇몇의 리듀서들에 의해 다뤄지거나 어떤 리듀서에 의해서도 다뤄지지 않을 수 있다.

이것의 일부분으로, 개발자는 동일한 액션에 대해 가능한 많은 리듀서 함수들이 별도로 다루게 하는 것이 좋다. 실제로, 경험을 통해 대부분의 액션들이 보통 단일 리듀서 함수에 의해서 다뤄진다는 것을 보여주었으며 이는 물로 괜찮다. 하지만, 이벤트로 액션을 모델링하는 것과 많은 리듀서들에게 이러한 액션들에 대해 반응하도록 하는 것은 어플리케이션의 코드로 하여금 규모가변성(scalability)을 더 낫게만들고 하나의 의미있는 업데이트를 위해서 여러개의 액션을 디스패치하는 데 필요한 시간을 최소화시켜준다.

###### - 여러 개의 액션을 연속적으로 발생시키지 마라.

거대하고 개념적인 트랜잭션 형태의 업데이트를 수행하기 위해 줄줄이 액션을 디스패치하는 것을 피하자. 가능하긴 하지만, 상당한 UI업데이트 비용을 발생시키고, 일부의 중간 상태들이 잠재적으로 다른 로직에 의해 유효하지 않을 수 있다. 적절한 상태 업데이트를 한번에 하는 단일 이벤트 타입액션을 디스패치하거나, 단일 UI업데이트를 위해 다수의 액션을 디스패치하는 데 액션 일괄처리 애드온을 사용하는 것을 고려해보자.

###### - 상태가 위치해야 하는 곳(리덕스 vs 로컬)에 대해 잘 판단해라.

리덕스의 3가지 원칙은 "어플리케이션 전체의 상태는 하나의 트리에 저장된다."라고 말한다. 이 문구는 지나치게 해석되었다. 이는 문자적으로 전체 앱의 모든 값이 반드시 리덕스 스토어에 저장되어야 한다는 것을 의미하지 않는다. 대신에 글로벌하고 앱 전체에서 사용한다고 생각하는 값들이 한 곳에 위치해야 한다는 것을 뜻한다. 일반적으로, 로컬값들은 가장 가까운 UI컴포넌트에 있어야 한다.

때문에, 리덕스 스토어에 어떤 상태가 있어야 하는지, 컴포넌트에는 어떤 상태가 있어야 하는지는 개발자에게 달렸다. 각 상태를 평가하고 어디에 있어야 하는지를 결정하는 데 도움을 주는 이 규칙들을 사용하라.

모든 state를 리덕스 안에 포함시켜야하나요? setState를 절대로 사용해서는 안되나요?

이에대한 확실한 정답은 없다. 몇몇의 사용자들은 그들의 어플리케이션에 대해 완전히 직렬화되고 제어할 수 있는 버전을 유지하기 위해 가급적이면 모든 데이터 조각들을 리덕스에 배치하는 것을 선호할 것이고 다른 사람들은 "현재 드롭다운이 열려있어야하나"와 같이 중요하지 않거나 UI state인 것은 컴포넌트의 내부적인 state로 정의하는 것을 선호할 수도 있다.

지역적인 컴포넌트 state를 사용하는 것은 괜찮다. 어플리케이션을 어떤 종류의 state로 만들지, 각각의 state가 어디에 위치할지 결정하는 것은 개발자들이 결정해야할 일이다. 당신에게 맞는 균형을 찾아 그렇게 해라.
다음은 어떤 종류의 데이터가 리덕스에 와야하는지에 대한 일반적인 규칙들이다.
- 어플리케이션의 다른 부분이 이 데이터와 관련이 있나?
- 원본 데이터를 기반으로 파생되는 데이터가 필요한가?
- 여러 개의 컴포넌트에서 같은 데이터가 필요한가?
- 데이터를 저장해야하는가?
- UI 컴포넌트를 핫 리로딩하는동안 해당 데이터를 일관적으로 유지하기를 원하는가?

###### - React Redux Hooks를 활용해라.

리액트 컴포넌트에서 리덕스 스토어와의 상호작용 시 기본적인 방법으로 useSelector와 useDispatch와 같은 React-Redux hooks API를 사용하는 것을 추천한다. 기존의 connect API 또한 여전히 잘 작동하지만 hooks API는 여러 면에서 더욱 사용하기 쉽다. hooks는 덜 간접적이고 코드가 더 짧고 간단하다.

hooks API는 성능과 데이터의 흐름 측면에서 connect와 다른 몇 가지의 절충안으로 도입되었지만, 이제는 hooks API를 사용하는 것이 기본적이다.

###### - 리덕스 스토어에서 데이터를 읽어서 사용하도록 더 많은 컴포넌트들을 연결해라.

리덕스의 데이터를 구독하는 더 많은 UI컴포넌트를 가지고 더 정밀하게 데이터를 읽는 것이 좋다. 이는 더 나은 UI 퍼포먼스로 이어지는데, 주어진 상태가 변화함에 따라 렌더링되는 컴포넌트가 더 적어지기 때문이다.

예를 들어, <UserList>컴포넌트를 연결해서 사용자 배열을 읽어들이기보다, <UserList>로 하여금 사용자 ID목록을 가져오게 하여 각 항목들을 <UserListItem userId={userId}>로 렌더링하고 <UserListItem>을 연결하여 스토어로부터 이 컴포넌트만의 사용자 정보를 가져오게 하는 방식이다.

이는 React-Redux의 connect() API와 useSelector()훅에 모두 적용된다.


###### - 함수형 컴포넌트 내부에서 `useSelector`를 여러번 호출해라.

`**useSelector` 훅을 사용해서 데이터를 가져올 때, 하나의 거대한 useSelector로 객체에 여러개의 결과를 담아 가져오기보다 useSelector를 여러번 호출해서 작은 양의 데이터를 가져오자.** mapState와 다르게, useSelector는 객체를 리턴할 필요가 없고, selector들이 더 작은 값들을 읽게 되면 주어진 상태 변경으로 인해 컴포넌트가 렌더링될 가능성이 낮다는 것을 의미한다.

그러나, 정밀함의 적절한 균형을 맞추도록 하라. 단일 컴포넌트가 상태 슬라이스의 모든 필드가 필요하다면, 각 필드에 별도의 selector를 사용하지 말고 하나의 useSelector를 사용해서 전체 슬라이스를 가져와라.

###### - 정적 타입 체킹 도구들을 사용해라.

그냥 자바스크립트보다 타입스크립트나 Flow와 같은 정적 타입 시스템을 사용하자.

###### - 디버깅을 위해 리덕스 개발 확장 프로그램을 사용해라.

리덕스 개발자도구 확장 프로그램으로 디버깅하면 다음과 같은 정보를 보여준다.

- 디스패치된 액션의 히스토리 로그
- 각 액션의 내용
- 액션이 디스패치되고 나서의 마지막 상태
- 액션이 되고 나서의 상태 차이
- 액션이 실제로 어디서 디스패치 되었는지에 대한 코드를 보여주는 함수의 스택 트레이스

또한 개발자도구는 시간여행 디버깅을 통해서 전체 앱의 상태와 각 시점에 따른 UI를 보기 위해 액션 히스토리를 앞뒤로 보게 해준다.

리덕스는 분명히 이런 종류의 디버깅을 가능하게 하도록 설계되었고, 개발자도구는 리덕스를 사용하는 가장 강력한 이유 중 하나이다.

###### - 상태 데이터는 Plain JS 객체를 활용해라

상태 트리를 위해서, Immutable.js와 같은 특별한 라이브러리 대신에 일반 자바스크립트 객체와 배열을 사용하자. Immutable.js를 사용하는 잠재적 이점이 있긴 하지만, 쉬운 참조 비교와 같이 일반적으로 언급되는 대부분의 목표는 일반적으로 불변 업데이트의 속성이며, 특정 라이브러리를 필요로하지 않는다. 또한 이를 통해 번들의 크기를 더 작게 줄이고 데이터의 형변환으로부터 오는 복잡성을 줄일 수 있다.

#### 중요도C

###### - domain/eventName 형식의 액션 이름을 사용해라

원래 리덕스 문서와 예제들은 액션타입을 정의할 때 "ADD_TODO나 "INCREMENT"와 같은 일반적으로 "SCREAMING SVAKECASE"컨벤션을 사용했다. 이는 상수값을 선언하는 대부분의 프로그래밍 언어들 컨벤션과 맞다. 단점은 대문자 문자열은 읽기 힘들다는 것이다.

NgRx커뮤니티는 "[도메인] 액션타입"과 같은 패턴을 사용하였다.

Redux Toolkit의 `createSlice` 함수는 "todos/addTodo"와 같은 도메인/액션 형태의 액션 타입들을 만들어낸다. 앞으로, 우리는 가독성을 위해 "도메인/액션" 컨벤션을 사용할 것을 제안한다.

###### - 비동기 로직은 Thunk를 이용해라.

리덕스는 확장 가능하도록 설계되었고, 미들웨어 API는 리덕스 스토어에 연결되어 비동기 로직들의 여러가지 형태들을 허용하도록 만들어졌다. 그러한 점에서, 사용자들은 필요에 적합하지 않다면, RxJS와 같은 특정 라이브러리를 배울 필요가 없다.

이는 다양한 리덕스 비동기 미들웨어 애드온을 만들어지게 했고, 어떤 비동기 미들웨어를 사용해야 하는가에 대한 혼동과 질문들을 발생시켰다.

기본적으로 Thunk 미들웨어를 사용하는 것을 추천하는데, 대부분의 경우에 충분하기 때문이다. 기본적인 Ajax 데이터 요청 또한 thunk의 async/await과 같은 문법은 가독성을 높여준다.

###### - 액션 생성 함수를 사용해라

액션 생성자 함수는 원래의 "Flux 구조" 접근방식에서 시작되었다. 리덕스에서, 액션 생성자들은 엄격하게 요구되지 않는다. 컴포넌트들이 다른 로직은 항상 인라인 방식으로 작성된 액션 객체를 가지고 dispatxh({type:"some/action"})을 사용할 수 있다.

그러나, 액션 생성자들을 사용하는 것이 일관성을 제공하며, 특리 액션의 내용을 채우는데(ID값을 생성하는 것과 같은) 어떤 준비나 추가적인 로직의 경우에 적용된다.

그러나 액션 생성자들을 손으로 작성하기보다, 액션 생성자와 타입을 자동으로 만들어주는 Redux Toolkit의 createSlice함수를 사용하는 것을 추천한다.

###### - 복잡한 로직은 컴포넌트 외부로 분리해라.

가능한 많은 로직을 컴포넌트 밖에 놓는 것이 좋다. 컴포넌트가 props로 데이터를 받아서 UI를 보여주는 "container/presentational"패턴을 권장하고있고 클래스 컴포넌트의 라이프사이클 메서드에서 비동기 로직을 다루는 것이 유지보수하기 어려워지기 때문이다.

여전히 복잡한 비동기 로직을 thunk를 사용해서 컴포넌트 밖으로 옮기는 것을 권장한다. 로직의 스토어의 상태를 읽어오는 경우라면 더더욱

###### - 스토어의 상태를 읽기 위해 Selector함수를 사용해라.

가능한 많은 로직을 컴포넌트 밖에 놓는 것이 좋다. 컴포넌트가 props로 데이터를 받아서 UI를 보여주는 "container/presentational"패턴을 권장하고있고 클래스 컴포넌트의 라이프사이클 메서드에서 비동기 로직을 다루는 것이 유지보수하기 어려워지기 때문이다.

여전히 복잡한 비동기 로직을 thunk를 사용해서 컴포넌트 밖으로 옮기는 것을 권장한다. 로직의 스토어의 상태를 읽어오는 경우라면 더더욱

###### - Selector함수의 이름은 select로 시작하게끔 작성해라.

선택될 값에 대한 설명을 결합하여 select-로 Selector함수의 이름을 정의하는것을 추천한다.

예를 들어 selectTodos, selectVisibleTodos, selectTodoById,,,

###### - 리덕스 안에 Form 관련 상태를 넣는 것은 피하는것이 좋다.

대부분의 폼 상태는 리덕스로 가면 안된다. 대부분의 경우에, 해당 데이터는 글로버하지도 않고, 캐싱되지도 않고, 한 번에 여러가지 컴포넌트들에 의해 사용되지도 않는다. 또한, 폼을 리덕스에 연결하는 것은 모든 변경 이벤트에 대해 액션을 디스패치하게 되며 이는 퍼포먼스 오버헤드를 유발시키고 어떠한 이득도 없다.

데이터가 궁극적으로 리덕스 안에 들어갔다고 해도, 폼이 자기 자신의 상태들을 로컬 컴포넌트의 상태에서 변경하도록 하고 사용자가 폼을 완성하면 그제서야 리덕스의 스토어를 업데이트하도록 액션을 디스패치하라.
