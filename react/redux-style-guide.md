# Redux style guide

#### 중요도A

###### - 상태를 직접적으로 수정하지 마라.

  상태를 직접적으로 수정하는 것은 리덕스에서 버그를 유발하는 가장 보편적인 요인이다. 이 버그가 발생하면 컴포넌트는 제대로 리렌더링되지 못하고 리덕스 개발자도구를 해용해 디버깅을 하는 데 많은 시간이 소요됩니다. reducer나 어플리케이션 코드 안에서나 직접으로 state를 변화시키는 것은 언제나 피해야 한다.

  `redux-immutable-state-invariant`와 같은 도구를 사용하면 개발 중에 state를 직접적으로 수정하는 것을 잡아낼 수 있고 `Immer`은 의도치않게 state가 변경되는 것을 방지해준다.

  Note: 존재하는 값을 복사하여 수정하는 것은 괜찮다. 이것은 갱신하는 로직을 불변하게 만드는 일반적인 부분이다. 또한, `Immer` 라이브러리를 사용하면 실제 값이 변하는 것이 아니기 때문에 "수정"하는 로직을 작성하는 것이 가능하다. `Immer`는 내부적으로 변화를 감지하고 불변적인 갱신 로직을 생성해준다.
  </br>

###### - Reducer함수는 순수해야한다.
  reducer함수는 오직 그 함수의 `state`와 `action`인자에 달려있다. 그리고 이 인자들만을 이요해 작업을 수행하고 값을 반환해야 한다. 이 함수에서는 **비동기적인 실행(AJAX 호출, timeout, promise 등)을 하거나 무작위적인 값(Date.now(), Math.random())을 생성하거나, reducer함수 외부의 값을 변화시키거나, 외부의 코드에 영향을 주는 코드를 작성 해서는 안된다.**
  </br>

###### - Serialize할 수 없는 값을 state나 action에 넣지 마라.
  Promise, Symbols, Map/Set 객체, 함수, 클래스의 인스턴스 등 serialize할 수 없는(나열할 수 없는?)값들을 삽입하는 것은 피해라. 이것은 redux의 디버깅 툴을 이용해 디버깅이 예상대로 작동하고 UI가 예상대로 갱신되는 것을 보장해준다.

  예외: 미들웨어때문에 reducer함수에 도달하기 전에 중단되는 경우에는 state나 action에 serialize할 수 없는 값을 삽입할 수 있다. 이러한 미들웨어로는 `redux-thunk`, `redux-promise`등이 있다.
  </br>

###### - 한 어플리케이션 당 store는 하나다.
  표준적인 redux 어플리케이션은 전체 어플리케이션에 사용되는 한 개의 redux store 인스턴스를 가져야 한다. 이것은 전형적으로 store.js와 같은 분리된 파일에서 정의된다.

  이상적으로는, 어플리케이션의 로직이 store를 직접적으로 import하는 것은 좋지 않다. 이것은 <Provider>를 통해 리액트 컴포넌트를 통과할 것이다. 또는 thunk와 같은 미들웨어를 통해 간접적으로 참조할 것이다. 극히 드문 경우에, 다른 로직 파일들에서 store를 import하는 것이 필요할 수도 있지만, 이것은 최후의 수단이 되어야 한다.
</br>

#### 중요도B

###### - Redux toolkit을 사용하여 리덕스 로직을 작성해라.
  `redux toolkit`은 리덕스를 사용할 때 추천하는 툴셋이다. 이것은 우리가 제안하는 모범적인 실행 사례들을 만드는 함수를 포함하고 있다. 이 사례들에는 수정을 감자하기 위해 stor를 세팅하는 것과 리덕스 개발자도구 extension을 사용할 수 있게 하는 것, Immer를 이용해 불변하는 update 로직을 단순화하는 것들이 포함되어있다.

  꼭 RTK(Redux ToolKit)를 사용할 필요는 없습니다. 필요하다면 다른 방안을 사용하는 것도 가능합니다. 그러나 RTK를 사용하면 당신의 로직이 단순해지고 당신의 어플리케이션이 좋은 기본값으로 설정될 것입니다.
  </br>

###### - Immer를 이용해 불변성이 보장되는 로직을 작성해라.
  불변적으로 update되는 로직을 직접 작성하는 것은 빈번하게 어렵고 에러를 발생시키기 쉽다. `Immer`는 당신이 '변하는' 로직을 작성하면서 불변적인 update로직을 간단히 작성할 수 있게 해준다. 그리고 당신의 개발중인 state를 정지시켜 변화를 캐치할 수도 있다. 우리는 불변하는 로직을 작성하기 위해 Immer를 사용하는 것을 추천한다. 가급적이면 redux toolkit의 한 부분으로서.
  </br>

###### - 기능 별 디렉토리 구조를 이용하여 파일 구조를 구성해라.
  리덕스 자체는 당신의 어플리케이션의 폴더와 파일이 어떻게 구성되어있는지 신경쓰지 않는다. 그러나 주어진 기능들을 한 공간안에 위치시키는 것은 유지보수를 좀 더 쉽게 한다.

  그래서, 우리는 **대부분의 어플리케이션이 "feature폴더"접근(모든 feature(기능)을 위한 파일이 같은 폴더에 위치하는 것)을 이용해 파일을 구조화할 것**을 추천한다. 주어진 feature(기능) 폴더 안에서, 해당 기능을 위한 리덕스 로직은 하나씩 slice된 파일로 쓰여야 하고, 가급적이면 `createSlice`리덕스 툴킷을 사용해라. (이것은 "ducks"패턴으로도 알려져있다.) 오래된 리덕스의 코드베이스가 종종 "action", "reducers"로 나누어진 폴더에 접근하는 "folder-by-type"방식을 사용하는 반면 관련된 로직을 한 공간에 저장하는 것은 코드를 찾거나 업데이트하기 쉽게 만들어준다.



###### - 리듀서에 가능한 많은 로직을 넣어라
  어디든 가능하다면, 새로운 state를 계산하는 로직을 prepare나 (이벤트 핸들러같은)action을 dispatch하는 코드보다는 적절한 리듀서 함수에 가능한 많이 넣도록시도해봐라. 이것은 더 많은 실제 어플리케이션 로직이 쉽게 테스트할 수 있게 되고, 시간차 디버깅을 더 효율적으로 만들어주고, mutation이나 버그를 일으키는 일반적인 실수를 막아준다.
  > - 리듀서에 로직을 작성하는 것을 선호하는 것에는 몇가지의 이유가 있다.
    - 리듀서함수는 순수함수이기 때문에, 테스트를 하기 쉽다. 그래서 리듀서에 더 많은 로직을 넣으면 넣을수록 테스팅이 쉬워진다.
    - 리덕스의 state는 언제나 "불변한 갱신"법칙을 따른다.  

###### - 리듀서는 상태모양(State Shape)을 가져야 한다.  
  리덕스의 루트 상태는 루트 리듀서 함수 1개가 가지고 계산한다. 유지보수를 위해, 루트 리듀서는 키/값 “슬라이스(slices)“에 의해 분할되며, 각각의 “슬라이스 리듀서”는 초기값을 제공하고 해당 상태에 대한 업데이트를 계산한다.

  또한, 슬라이스 리듀서는 계산된 상태의 일부로 반환되는 값들을 제어해야 한다. return action.payload 와 return {...state, ...action.payload} 와 같은 “보이지 않는 spread 및 리턴”의 사용을 최소화 해야 하는데 그 이유는, 컨텐츠를 올바른 포맷으로 수정하기 위해 액션을 디스패치하는 코드에 의존하고, 리듀서는 상태가 어떻게 생겼는지 신경을 쓰지 않기 때문이다. 액션의 컨텐츠가 잘못되었다면 이는 버그로 이어질 수 있다.

  참고 : “spread 리턴” 리듀서는 폼의 데이터를 수정하는 것과 같은 경우에 합리적인 선택이 될 수 있는데, 폼의 각 필드에 대해 별도의 액션 타입을 작성하는 것은 시간낭비가 될 수 있고 별로 이득이 없기 때문이다.


###### - slice는 저장되는 데이터에 기반하여 이름을 지어라
리듀서 로직을 분리하는 표준적인 접근방식은 상태의 "슬라이스(slice)"기반이다. 마찬가지로, `combineReducers` 는 이러한 슬라이스 리듀서들을 하나의 거대한 리듀서 함수로 합치는 표준함수이다.

`combineReducers` 에 넘겨지는 객체의 키 이름은 결과적으로 나올 상태 객체의 키 이름을 정의한다. 내부에 저장되는 데이터의 이름을 따서 키 이름을 지정하도록 하고, "reducer"와 같은 이름을 피하자. 객체가 `{userReducer: {}, postsReducer: {}}`보다 `{users: {}, posts: {}}` 와 같이 생겨야 한다는 말이다.

`combineReducers` 는 리듀서 함수가 모두 들어있는 객체를 받고 키 이름과 동일한 상태 객체들을 생성한다. 함수 객체의 키 이름이 상태 객체의 키 이름을 정의한다는 것을 의미한다. 만약 리듀서를 "00reducer"와 같은 변수이름으로 정의할 경우 상태의 이름이 "00reducer"로 정의될 것이다.

명시적으로 `key: value` 문법을 사용해도 좋다.

```jsx
const rootReducer = combineReducers({
  userReducer, // (X)
	users, // (O)
  users: userReducer, // (O)
  // 상태 객체의 이름: 상태 객체를 생성하는 리듀서함수
});
```

###### - 상태 구조는 컴포넌트가 아닌, 데이터 종류에 따라 구성해라

###### - 중첩되고 복잡한 상태를 정규화시켜라.

###### - 액션은 이벤트처럼 다루어라.

###### - 의미있는 액션 이름을 사용해라

###### - 하나의 액션에 여러 개의 리듀서가 반응할 수 있게 해라

###### - 여러 개의 액션을 연속적으로 발생시키지 마라.

###### - 상태가 위치해야 하는 곳(리덕스 vs 로컬)에 대해 잘 판단해라.

###### - React Redux Hooks를 활용해라.

###### - 리덕스 스토어에서 데이터를 읽어서 사용하도록 더 많은 컴포넌트들을 연결해라.

###### - 함수형 컴포넌트 내부에서 `useSelector`를 여러번 호출해라.

###### - 정적 타입 체킹 도구들을 사용해라.

###### - 디버깅을 위해 리덕스 개발 확장 프로그램을 사용해라.

###### - 상태 데이터는 Plain JS 객체를 활용해라


#### 중요도B

###### - domain/eventName 형식의 액션 이름을 사용해라

###### - 비동기 로직은 Thunk를 이용해라.

###### - 액션 생성 함수를 사용해라

###### - 복잡한 로직은 컴포넌트 외부로 분리해라.

###### - 스토어의 상태를 읽기 위해 Selector함수를 사용해라.

###### - Selector함수의 이름은 select로 시작하게끔 작성해라.

###### - "대부분의" Form 관련 상태는 리적스에서 관리하지 마라.
