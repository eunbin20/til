# 2021년 6월 첫째주 TIL
오늘 내가 배운 것들(Today I Learned)

---------------------------------------
## async/await, HOF
## 알고리즘 1일 1문제

<details open>
<summary>2021-06-07</summary>

#### async과제
- 1 ~ 3



</details>

<details open>
<summary>2021-06-08</summary>
#### async과제
- 4 ~ 6


#### 알고리즘
- reaptCharacter


</details>

<details open>
<summary>2021-06-09</summary>
#### async과제
- 7 ~ 11

#### 알고리즘
- frequency

</details>

<details open>
<summary>2021-06-10</summary>

</details>

<details open>
<summary>2021-06-11</summary>

#### async과제
- 리팩토링 + 제출 완료

- higher order function 학습자료 + elequent어쩌구

고차함수는 함수를 인자로 받거나 함수를 반환하는 함수

일급객체는 함수의 인자로 쓰이거나 반환값으로 쓰이거나 자료구조에 저장할 수 있는 객체

자바스크립트에서 함수는 일급 객체이며 일급객체인 함수는 일급 함수라고 한다.

- async await 학습자료

async 함수는 무조건 프로미스 객체를 반환한다.

async 함수의 반환값이 존재하는 경우, 예를 들어 return 5; 이러면 이 함수의 반환값은 프로미스 객체의 resolve값이 5인 프로미스 객체가 된다.

</details>

<details open>
<summary>2021-06-12</summary>

- Big-O

 주로 시간복잡도를 나타내는 지표

- async/await

반환값은 무조건 프로미스 객체

</details>

<details open>
<summary>2021-06-13</summary>

- 프로미스의 장점과 단점

기존의 콜백함수에 의존했던 비동기 프로그래밍에서는 작업의 제어권이 다른 웹 api등에 있었기 때문에 작업이 진행되는 동안 결과를 전달받을때까지 개발자는 다른 작업도 하지 못한 채 기다리고있을 수밖에 없었다. 내가 작성한 코드의 제어가 다른 서드파티에 넘어가있었기 때문에 그곳에서 발생할 예기치못한 에러나 돌발 변수들을 처리하기가 어려웠고 여러 개의 비동기작업이 연쇄되어 일어나는 경우에는 코드가 중첩되어 콜백 지옥에 빠지기 쉬웠고 모든 작업마다 에러처리를 해줘야했기 때문에 코드가 지저분하고 가독성이 떨어지게 되었다.

그러나 프로미스가 도입되 이후부터는 비동기 작업에 대한 약속을 받아옴으로써 다른 곳으로 넘어갔던 제어권을 다시 찾아올 수 있게 되었고 연쇄적인 비동기작업도 메서드 체이닝을 통해 좀 더 가독성 높고 깔끔한 코드를 작성할 수 있게 되었다. 프로미스를 통해 개발자는 비동기작업에 대한 확실한 보장(?)을 받은 상태에서 그 이후의 작업들을 처리할 수 있게 된다.
</details>
