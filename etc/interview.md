# 프론트엔드 개발자 면접 질문 정리

### 기본

- 프로토타입

  - 자바스크립트에서 모든 객체는 생성자함수를 통해 만들어진다. 그리고 각각의 생성자함수는 prototype이라는 객체를 가지고 있고 생성자함수를 통해 만들어진 객체는 그 생성자함수가 가지고 있는 prototype 객체를 프로토타입 체인을 통해 접근할 수 있게 된다.
  - 자바스크립트에서 다른 객체의 원형이 되는 객체
  - 객체를 만들기 위한 청사진 같은 역할
  - 프로토타입을 통해 객체를 확장하고 객체가 기본적으로 가지는 속성과 메서드를 정의함으로써 객체지향적인 프로그래밍을 구현할 수 있게 된다.
  - 프로토타입 객체의 최상위 객체는 Object.prototype(=`null`)
  - 프로토타입 체이닝(프로토타입 상속은 어떻게 일어나는가?)

    모든 자바스크립트 객체는 던더프로토(`__proto__`)속성을 가지고 있고 이 속성을 통해 상위 프로토타입 속성에 접근할 수 있다. 특정 객체의 속성에 접근하려하면 우선 해당 객체에 그 속성이 있는지 확인한다. 속성이 없다면 던더프로토를 이용해 상위 프로토타입 객체를 탐색하게 되고 최종적으로 최상위 프로토타입 객체인 Object의 프로토타입 속성까지 탐색한 후 해당 속성이 없다면 `undefined`를 반환한다.

  - 클래스와 비교

    클래스 기반 언어의 경우 자식 클래스가 부모 클래스를 상속하고 그 클래스를 통해 객체가 생성되는 반면 프로토타입 기반 언어에서는 객체가 객체에게서 속성과 메서드를 상속받을 수 있다.

- this

  - 코드 실행 시 바인딩이 이루어지는 실행컨텍스트 중 하나. - 코드를 실행시키는 주체
  - this 값이 결정되는 경우(우선적으로 적용되는 순서대로)
    - 함수가 new 키워드와 함께 사용되는 경우: 새로운 객체
    - call/bind/apply 메서드를 통한 명시적 바인딩: 인자로 전달되는 객체
    - 객체의 메서드로서 호출되는 경우: 해당 객체
    - 일반함수 실행문으로 실행되는 경우: 전역객체(브라우저: `window`, node: `global`) / strict mode => `undefined`
    - 화살표함수: 주변 스코프의 this(바인딩 x)

- arrow function

  - ES6 문법에서 추가된 함수 정의 방식
  - 익명함수로 작성, 기존 함수에 비해 구문이 짧고 중괄호와 return문을 생략할 수 있다.
  - this, argument와 new.target 등과 같은 바인딩을 지원하지 않기 때문에 생성자함수를 사용할 수 없고 객체의 메서드로써 사용되기에 적합하지 않다.

- closure

  - 함수가 생성될 당시의 외부 함수의 로컬 스코프를 참조할 수 있는 내부함수를 의미.
  - 외부함수의 실행이 종료되어도 외부함수의 렉시컬 환경을 캡쳐하여 함수가 어느 위치에서 실행되더라도 외부의 렉시컬 환경의 변수에 접근할 수 있다.
  - 예제: curring, memoize, react useState hook

- restful

  - rest란 웹상에서 네트워크를 통해 데이터를 주고받을 때 http프로토콜의 장점을 최대한 활용하기 위한 제약조건, 규범
  - rest아키텍쳐를 활용해 만든 rest api를 이용한 어플리케이션, 또는 그 api를 restful하다고 말할 수 있다.
  - rest 아키텍쳐
    - 요청 행위를 http메소드로 표현, 요청 데이터(상태)를 uri로 표현
    - 서버 클라이언트 구조
    - stateless
    - cashable
    - 통합된 인터페이스
    - 계층화된 시스템
  - soap

- block vs non-block

<aside>
💡 블록과 논블록은 함수 호출시에 실행되는 동작에서 발생하는 차이. 제어권의 이동
블록은 호출된 함수가 요청된 동작을 모두 마칠 때까지 제어권을 가지고서 호출한 함수에게 바로 돌려주지 않음
논블록은 호출된 함수가 동작을 요청하고 바로 리턴되어 제어권을 넘겨주어 호출한 함수가 다른 일을 진행할 수 있도록 해주면 논블록

</aside>

- 동기, 비동기

<aside>
💡 한 작업에서 다른 작업의 완료 여부를 확인하는가
동기방식에서는 어떠한 요청을 보내고 작업이 진행될 때 해당 작업이 끝나야 다음 작업이 진행될 수 있다. 
비동기방식에서는 어떠한 요청을 보내고 응답이 오지 않아도 다음 작업을 진행할 수 있다.

</aside>

자바스크립트는 논 블로킹, 동기 방식으로 작동한다. 하지만 비동기 작업을 webAPI에 위임하여 이벤트루프와 콜백큐를 통해 비동기적인 작업을 수행할 수 있게 된다.

### 심화

- 브라우저가 렌더링되는 과정

- script 태그의 위치로 적절한 위치는?

- CSS in JS vs. CSS in CSS, CSS 전처리기의 차이점과 각각의 장단점

- React hook의 장점

- SSR과 CSR의 차이점

- 사용자 로그인 인증 관련

  - JSON Web Token

  - O-Auth2.0

  - 토큰방식과 세션 쿠키 방식을 사용한 이유

- DNS란?

- 리액트에서 리렌더링이 일어나는 조건

- 리액트에서의 성능 최적화

- 상태관리

  - 상태관리를 왜 하는걸까
