20210408TIL

과제 코드 분석
상속
컴포넌트
팩토리함수
팩토리함수를 이용해 생성자함수 구현하기
모든 함수는 리턴값을 반환한다.
그리고 모든 함수는 생성자함수로서 호출될 수 있다.
함수가 생성자함수로서 호출되었을 때 
함수의 리턴값이 없거나 원시값인 경우 this는 인스턴스
함수의 리턴값이 객체면 this는 그 객체

Component함수와 CanolaUI와 Clock, Day의 관계

우선 자바스크립트에서 모든 객체는 생성자함수로 만들어집니다.
그리고 그 함수들은 정의될 때 몇가지 특징을 가지고 있는데요.
먼저 모든 함수는 생성될 때 생성자의 자격이 주어집니다. 그래서 어떤 함수든 new 키워드를 통해 객체를 만들 수 있어요.
그리고 두 번째는 고유의 prototype 객체를 가지고있다는 것입니다. 
그리고 함수를 통해 만든 인스턴스객체는 이 prototype 객체를 상속받아 사용할 수 있게 되고 그래서 자바스크립트의 객체는 따로 지정하지 않아도 특정한 메소드와 속성에 접근하고 사용할 수 있게 되는 것입니다.
이렇게 다른 객체의 속성과 메소드를 상속하는 객체를 프로토타입이라 합니다.
그렇다면 프로토타입은 왜 필요한것일까요?
예를 들어 책의 인스턴스 객체를 만드는 Book 생성자함수가 있다고 해봅시다.
함수 내부에서 name값에 name을 저장하고 id 값에 id를 저장했습니다. 그리고 displayInfo 값에 함수를 저장했습니다. 
이제 책의 인스턴스를 만들면 book1에 대한 이름, 아이디, 함수의 값이 메모리에 저장되고 book2도 마찬가지겠죠?
그런데 만약 저장해야 하는 책의 개수가 100권이라면? 실제 값과는 조금 다르겠지만 name을 저장하는 메모리 100개, id 값을 저장하는 메모리 100개, 함수를 저장하는 메모리는 함수는 참조값이기 때문에 그 변수의 주소들을 저장하는 메모리까지 100개 넘게 필요하겠죠? 
이때 이름과 아이디는 책 하나마다 고유의 값을 가지고있기 때문에 어쩔 수 없지만 함수같은 경우는 같은 값을 공유하고있잖아요. 그래서 생성자함수에서 속성을 상속받아 사용해야할 필요성이 생겼고 이를 구현한 것이 프로토타입입니다.
Function Person (name) {
  this.name = name;
}

Person.prototype.logName = fucntion () {
  console.log(this.name);
}

person1 = new Person(); // new 키워드 이용해 생성자 함수를 실행


