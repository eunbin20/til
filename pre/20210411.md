20210408TIL

과제 코드 분석
상속
컴포넌트
팩토리함수
팩토리함수를 이용해 생성자함수 구현하기
모든 함수는 리턴값을 반환한다.
그리고 모든 함수는 생성자함수로서 호출될 수 있다.
함수가 생성자함수로서 호출되었을 때 
함수의 리턴값이 없거나 원시값인 경우 this는 인스턴스
함수의 리턴값이 객체면 this는 그 객체

Component함수와 CanolaUI와 Clock, Day의 관계

우선 자바스크립트에서 모든 객체는 생성자함수로 만들어집니다.
그리고 그 함수들은 정의될 때 몇가지 특징을 가지고 있는데요.
먼저 모든 함수는 생성될 때 생성자의 자격이 주어집니다. 그래서 어떤 함수든 new 키워드를 통해 객체를 만들 수 있어요.
그리고 두 번째는 고유의 prototype 객체를 가지고있다는 것입니다. 
그리고 함수를 통해 만든 인스턴스객체는 이 prototype 객체를 상속받아 사용할 수 있게 되고 그래서 자바스크립트의 객체는 따로 지정하지 않아도 특정한 메소드와 속성에 접근하고 사용할 수 있게 되는 것입니다.
이렇게 다른 객체의 속성과 메소드를 상속하는 객체를 프로토타입이라 합니다.
그렇다면 프로토타입은 왜 필요한것일까요?
예를 들어 책의 인스턴스 객체를 만드는 Book 생성자함수가 있다고 해봅시다.
함수 내부에서 name값에 name을 저장하고 id 값에 id를 저장했습니다. 그리고 displayInfo 값에 함수를 저장했습니다. 
이제 책의 인스턴스를 만들면 book1에 대한 이름, 아이디, 함수의 값이 메모리에 저장되고 book2도 마찬가지겠죠?
그런데 만약 저장해야 하는 책의 개수가 100권이라면? 실제 값과는 조금 다르겠지만 name을 저장하는 메모리 100개, id 값을 저장하는 메모리 100개, 함수를 저장하는 메모리는 함수는 참조값이기 때문에 그 변수의 주소들을 저장하는 메모리까지 100개 넘게 필요하겠죠? 
이때 이름과 아이디는 책 하나마다 고유의 값을 가지고있기 때문에 어쩔 수 없지만 함수같은 경우는 같은 값을 공유하고있잖아요. 그래서 생성자함수에서 속성을 상속받아 사용해야할 필요성이 생겼고 이를 구현한 것이 프로토타입입니다.
Function Person (name) {
  this.name = name;
}

Person.prototype.logName = fucntion () {
  console.log(this.name);
}

person1 = new Person(); // new 키워드 이용해 생성자 함수를 실행




20210412 월욜 오피스아워

Lodash라는 라이브러리를 똑같이 만드는 거
주의할 점
npm start x
SpecRunner 열어서
Koans랑 비슷한거

예를 들어 indexof
필터 이런거 내용이 없으면 작성
빈 함수들을 작성
뒤에 5개 정도는 어려운 편
부트캠프 어드미션은 뒤에 5문제 정도 난이도
TIP은 필수는 아니다. 제안
다음주는 비동기
이번주 과제와 코딩테스트가 내용은 달라도
형식이 매우 유사하다
이번 과제는 17개 문제
테스트에서는 다른 메소드
켄님이 만든 메소드 구현하라고 써있다

클로저는 코드에서 이해할 수 있어야함
코드에서 어떻게 형성되는지 판별하는 것
재귀를 적용할 수 있는 능력은 어렵다.
재귀를 응용, 적용은 시간이 걸리지만
이번 주를 시작으로 시도를 해봐라

이번주 다음주는 실습에서 이해하고 응용하는 것이 중요
개념공부는 적당히 보고 
코드에서 실행할 수 있게 
클로저랑 재귀는 선비처럼 굴면 안돼고 덤벼들어야함
클로저 퀴즈는 인터넷에 찾으면 금방 나옴
근데 최대한 스스로 판별해보려고 애써봐라
금요일 쯤에 이야기 해볼것
클로저퀴즈- 인터넷에 찾아보지 말자...
재귀 두 번째 문제도 인터넷에 찾아보지 말고 스스로
혼자서 시
