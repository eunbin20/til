
velog.io/@ursr0706/%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90﻿


원시 값과 객체의 비교

자바스크립트의 원시값과 객체의 비교에 대한 내용 정리

velog.io
자바스크립트의 데이터 타입은 두 종류로 나눌 수 있다.

- 원시값 : string, number, boolean, null, undefined

- 참조값 : object, symboll



원시값과 참조값은 두 값 모두 선언과 할당의 과정을 거쳐 변수값으로 할당된다.



선언: 변수와 주소값 매칭

할당: 변수의 주소값에 값을 할당





원시값과 참조값의 차이점


일반적으로 원시값의 값을 조작할 때 '값으로 접근'한다고 표현한다.



하지만 엄밀히 말하면 원시값은 원본값에 접근하는 것이 아니라 원본 값이 담긴 주소에 접근하는 것이다.



그러나 *원시값은 불변성(immutability)을 띄고 있다.



 (→ 여기서 변경 불가능하다고 진술하는 값이란 변수가 아니라 '값'을 뜻한다는 것에 주목해야 한다.)



그렇기 때문에 변수의 값이 바뀔 때 해당 원시값이 변경되는 것이 아니라 새로운 메모리 공간을 확보하여 새로운 값을 담은 주소를 재할당하여 변수의 값이 변경되는 것이다.


즉, 변수는 값이 담긴 주소값을 저장하고 있고 그 주소값이 바뀌면서 변수 안에 담긴 값이 변경된다.



따라서 '값으로 접근한다'라고 인식하고 데이터를 조작해도 큰 문제는 없을 것이다.







원시값은 데이터의 타입에 따라 데이터의 크기가 정해져있는 반면 참조값의 데이터의 크기는 가변적이다.



참조값의 객체을 조작할 때는 객체 자체가 아니라 객체의 참조를 조작하는 것이다. 따라서 객체를 가리키는 값은 '참조로 접근한다'고 표현한다.



참조값은 언제든 프로퍼티와 메서드를 추가하거나 삭제할 수 있다.



* 원시값에는 프로퍼티가 없지만, 추가해도 에러가 생기진 않는다.


< 문자열의 특성 >
문자열은 앞서 설명한 바와 같이 원시값이다.



그러나 *유사배열이기 때문에 마치 배열처럼 인덱스값으로 문자를 불러올 수 있고 .length 등의 메서드도 사용할 수 있다.



* 유사배열이란 쉽게 말해 배열은 아니지만 배열처럼 사용 가능한 요소를 말한다.
 배열인지 아닌지 판단하는 방법은 Array.isArray(요소) , array instanceof 요소 명령으로 판별할 수 있다.


다른 데이터타입은 값의 크기와 상관없이 동일한 메모리 공간이 필요하다.



예를 들어 숫자형 데이터의 경우 1도, 100000도 동일한 8바이트가 필요하다.



그러나 문자열의 경우 그 값의 길이에 따라 필요한 메모리 공간이 다르다.



var str = "abcde";

console.log(str[0]); // "a"

str[0] = "s";

console.log(str); // "abcde"
 - 문자열은 인덱스를 사용해 값에 접근할 수 있다.



 - 그러나 변경 불가능한 원시값이기 때문에 이미 생성된 문자열의 일부를 변경해도 반영되지 않는다.



< 얕은 복사와 깊은 복사 >



모든 원시값의 복사에는 깊은 복사가 일어난다.



참조값의 복사에서는 데이터 자체를 변경할 때는 깊은 복사가 일어나지만 내부의 프로퍼티를 변경할 때는 얕은 복사가 일어난다.



얕은 복사가 일어나게 되면 복사된 객체를 변경했을 때 원본 객체도 함께 변경된다.



그러나 복사된 객체를 변경해도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다.



이러한 문제를 해결하기 위해 참조값이 복사될 때 깊은 복사가 일어나도록, 즉, 참조값이 불변객체가 되도록 작업을 해주어야 한다.



그 방법에는 00가지가 있다.



1. 2. 3. 4...



- 원시값의 복사



- 참조값의 복사



원시값의 복사에서는 깊은 복사가 일어나고 참조값의 복사에서는 얕은 복사가 일어난다.



참조값의 복사에서 일어나는 얕은 복사로 인해
